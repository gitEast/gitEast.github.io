---
title: 教小鳄鱼写代码之哈希表
date: 2024-01-10 19:39:26
categories:
  - '数据结构与算法'
tags:
  - 'JavaScript'
  - '哈希表'
---

## 一、邂逅哈希表

### 1.1 为什么出现哈希表这种数据结构？

> 由于哈希表是基于数组实现的，在此针对数组出发，对哈希表的出现进行评判

- 数组
  - 优势
    1. 基于下标查找元素，时间复杂度 O(1)
  - 劣势
    1. 基于元素查找元素，时间复杂度 O(n)

实际上针对于简单元素（如 `Number`, `String` 等），已知元素查找元素未免多此一举，上述劣势其实是针对于 `key/value` 结构而言，已知 `key`，求 `value`。

举个例子，将姓名、身高、体重等信息作为 `value` 存储在数组中，已知我的姓名作为 `key`，你要如何得到对应的 `value` 呢？

—— 只能是遍历。

那么有没有一种方法，能利用数组的下标这一特性呢？比如对我的姓名 `key` 进行再计算，得到一个数字作为下标值 `index`，在 `array[index]` 存入我的姓名、身高、体重等信息。

—— 这，就是哈希表存在的理由。

### 1.2 初步了解哈希表

> 这世上不可能存在完美的事物，纵使是圆，也有人嫌它没有棱角。—— by 郑鳄（嘿嘿，我瞎说的）

对 `key` 进行再计算得到的下标值 `index`，我们该如何保证得到的 `index` 可以填满整个数组呢？

针对这个问题，首先要明确：

1. 对 `key` 进行再计算的方法
2. 整个哈希表的长度（鉴于哈希表基于数组实现，其实就是数组的长度）

#### 1.2.1 再计算的方法

这就千人千面，完全可以设计自己的方法了。（注意：这也叫算法[手动狗头]）

举个例子，我的名字是 'crocodile'，字母 `a` 表示 1，`b` 表示 2，依此类推，至 `z` 是 26。计算方式是 `3 * 10^8 + 18 * 10^7 + 15 * 10^6 + 3 * 10^5 + 15 *  10^4 + 4 * 10^3 +　9 * 10^2 + 12 * 10 + 5`（dbq，名字有点长了）。

#### 1.2.2 哈希表的长度

针对上述算法，哈希表的长度，够呛。而实际上，对于 Native Speaker 的词汇量也仅在三万左右。实在是杀鸡用牛刀了。

当然，我们可以对算法得到的下标值 `index` 进行压缩，但不可避免地，要么哈希表的长度大于实际的元素个数，要么多个元素为同一个下标值大打出手（bushi）。事实上，这两种情况都会出现。

### 1.3 深入了解哈希表

上述的两个问题，空间资源浪费与下标值冲突，四个字，两级对抗。对此，聪明的你，自行权衡去吧。

但对于下标值冲突的问题，我们可以粗浅地解决一下：

1. 放元素会冲突，那就放数组（链表也行；再来个哈希表，也不是不行，就是有那么点子傻气）。 —— 拉链法
2. 反正我空间资源要浪费，那就往后找个空地放嘛。 —— 线性探测

现在一般使用拉链法，少用线性探测了。反正我是不会线性探测的，下面也不写。

### 1.4 哈希表中的术语

> ~~凑个字数（划掉）~~ 复习一下术语，加深印象。

- 哈希函数：对 `key` 进行再计算得到 `index` 的方法
- 拉链法
- 线性探测

## 二、编写一个自己的哈希表结构

### 2.1 结构先写上去

```javascript
/**
 * @description: 哈希表
 */
class HashTable {
  #bucket = []; // 哈希表基于数组实现，即该数组
  #length = 7; // 初始哈希表长度
  #count = 0; // 元素个数

  constructor() {}

  /**
   * 哈希函数（私有方法）
   * @param {String} key
   */
  #hash(key) {}

  /**
   * 查询
   * @param {String} key
   */
  get(key) {}

  /**
   * 添加
   * @param {String} key
   * @param {Array} value
   */
  set(key, value) {}

  /**
   * 删除
   * @param {String} key
   */
  delete(key) {}
}
```

### 2.2 填充结构（不考虑冲突情况）

```javascript
/**
 * @description: 哈希表
 */
class HashTable {
  #bucket = []; // 哈希表基于数组实现，即该数组
  #length = 7; // 初始哈希表长度
  #count = 0; // 元素个数

  constructor() {}

  /**
   * 哈希函数（私有方法）
   * @param {String} key
   * @returns {Number} 下标值
   */
  #hash(key) {
    let res = 0;
    const BASE = 'a'.charCodeAt();
    for (const char of key) {
      res += res * 10 + char.charCodeAt() - BASE;
    }
    return res % this.#length;
  }

  /**
   * 查询
   * @param {String} key
   */
  get(key) {
    const index = this.#hash(key);
    return this.#bucket[index];
  }

  /**
   * 添加
   * @param {String} key
   * @param {Array} value
   */
  set(key, value) {
    const index = this.#hash(key);
    this.#bucket[index] = value;
    this.#count++;
  }

  /**
   * 删除
   * @param {String} key
   */
  delete(key) {
    const index = this.#hash(key);
    const value = this.#bucket[index];
    this.#bucket[index] = undefined;
    this.#count--;
    return value;
  }
}
```

### 2.3 完善结构 1（考虑冲突）

1. 将 `#bucket` 升级为 `#storage`，从 `#storage` 中取出的才是`bucket`
   - 数组里放 `value` => 数组里放数组放 `[key, value]`
2. 除 `#hash` 方法不变外，其他方法均做对应修改

```javascript
/**
 * @description: 哈希表
 */
class HashTable {
  #storage = []; // 哈希表基于数组实现，即该数组
  #length = 7; // 初始哈希表长度
  #count = 0; // 元素个数

  constructor() {}

  /**
   * 哈希函数（私有方法）
   * @param {String} key
   * @returns {Number} 下标值
   */
  #hash(key) {
    let res = 0;
    const BASE = 'a'.charCodeAt();
    for (const char of key) {
      res += res * 10 + char.charCodeAt() - BASE;
    }
    return res % this.#length;
  }

  /**
   * 查询
   * @param {String} key
   */
  get(key) {
    const index = this.#hash(key);
    const bucket = this.#storage[index];
    if (!bucket) return null;
    const element = bucket.find((item) => item[0] === key);
    return element ? element[1] : null;
  }

  /**
   * 添加
   * @param {String} key
   * @param {Array} value
   */
  set(key, value) {
    const index = this.#hash(key);
    if (!this.#storage[index]) this.#storage[index] = [];
    this.#storage[index].push([key, value]);
    this.#count++;
  }

  /**
   * 删除
   * @param {String} key
   */
  delete(key) {
    const index = this.#hash(key);
    const bucket = this.#storage[index];
    if (!bucket) return null;
    const elIndex = bucket.findIndex((item) => item[0] === key);
    if (elIndex === -1) return null;
    const value = bucket[elIndex][1];
    bucket.splice(elIndex, 1);
    this.#count--;
    return value;
  }

  print() {
    console.log(this.#storage);
  }
}

// 测试代码
const hash = new HashTable();
hash.set('a', '111');
hash.set('b', '222');
hash.set('c', '333');
hash.set('h', '888');
hash.print();
console.log(hash.delete('a'));
console.log(hash.delete('b'));
hash.print();
```

### 2.4 完善结构 2（考虑扩容）

如果不扩容的话，更多的 `key/value` 加入，由于下标值冲突，又成为普通的数组了。

那么何时扩容呢？`#count` / `#length` > 0.75 时。

扩容也有小技巧：使用质数作为哈希表长度，下标值分布更均匀哦。

```javascript
/**
 * @description: 哈希表
 */
class HashTable {
  #storage = []; // 哈希表基于数组实现，即该数组
  #length = 7; // 初始哈希表长度
  #count = 0; // 元素个数

  constructor() {}

  /**
   * 哈希函数（私有方法）
   * @param {String} key
   * @returns {Number} 下标值
   */
  #hash(key) {
    let res = 0;
    const BASE = 'a'.charCodeAt();
    for (const char of key) {
      res += res * 10 + char.charCodeAt() - BASE;
    }
    return res % this.#length;
  }

  #getNextPrime(num) {
    while (!isPrime(num)) num++;
    return num;

    function isPrime(num) {
      const sqrt = Math.sqrt(num);
      for (let i = 2; i <= sqrt; i++) {
        if (num % i === 0) return false;
      }
      return true;
    }
  }

  #resize(length) {
    this.#length = this.#getNextPrime(length);
    this.#count = 0;
    const oldStorage = this.#storage;
    this.#storage = [];
    for (const bucket of oldStorage) {
      if (bucket) {
        for (const element of bucket) {
          this.set(element[0], element[1]);
        }
      }
    }
  }

  /**
   * 查询
   * @param {String} key
   */
  get(key) {
    const index = this.#hash(key);
    const bucket = this.#storage[index];
    if (!bucket) return null;
    const element = bucket.find((item) => item[0] === key);
    return element ? element[1] : null;
  }

  /**
   * 添加
   * @param {String} key
   * @param {Array} value
   */
  set(key, value) {
    const loadFactor = (this.#count + 1) / this.#length;
    if (loadFactor > 0.75) {
      this.#resize(this.#length * 2);
    }
    const index = this.#hash(key);
    if (!this.#storage[index]) this.#storage[index] = [];
    this.#storage[index].push([key, value]);
    this.#count++;
  }

  /**
   * 删除
   * @param {String} key
   */
  delete(key) {
    const index = this.#hash(key);
    const bucket = this.#storage[index];
    if (!bucket) return null;
    const elIndex = bucket.findIndex((item) => item[0] === key);
    if (elIndex === -1) return null;
    const value = bucket[elIndex][1];
    bucket.splice(elIndex, 1);
    this.#count--;
    return value;
  }

  print() {
    console.log(this.#storage);
    console.log(this.#length);
  }
}

// 测试代码
const hash = new HashTable();
hash.set('a', '111');
hash.set('b', '222');
hash.set('c', '333');
hash.set('h', '888');
hash.print();
hash.set('d', '444');
hash.set('e', '555');
hash.print();
```

### 2.5 完善结构 3（考虑缩容）

> 考虑了扩容，怎么能不考虑缩容，厚此薄彼呢？

1. 何时缩容？loadFactor < 0.25 时
2. 如果哈希表长度 < 7，就别缩啦

```javascript
/**
 * @description: 哈希表
 */
class HashTable {
  #storage = []; // 哈希表基于数组实现，即该数组
  #length = 7; // 初始哈希表长度
  #count = 0; // 元素个数

  constructor() {}

  /**
   * 哈希函数（私有方法）
   * @param {String} key
   * @returns {Number} 下标值
   */
  #hash(key) {
    let res = 0;
    const BASE = 'a'.charCodeAt();
    for (const char of key) {
      res += res * 10 + char.charCodeAt() - BASE;
    }
    return res % this.#length;
  }

  #getNextPrime(num) {
    while (!isPrime(num)) num++;
    return num;

    function isPrime(num) {
      const sqrt = Math.sqrt(num);
      for (let i = 2; i <= sqrt; i++) {
        if (num % i === 0) return false;
      }
      return true;
    }
  }

  #resize(length) {
    this.#length = this.#getNextPrime(length);
    console.log('-----', this.#length);
    if (this.#length < 7) this.#length = 7;
    this.#count = 0;
    const oldStorage = this.#storage;
    this.#storage = [];
    for (const bucket of oldStorage) {
      if (bucket) {
        for (const element of bucket) {
          this.set(element[0], element[1]);
        }
      }
    }
  }

  /**
   * 查询
   * @param {String} key
   */
  get(key) {
    const index = this.#hash(key);
    const bucket = this.#storage[index];
    if (!bucket) return null;
    const element = bucket.find((item) => item[0] === key);
    return element ? element[1] : null;
  }

  /**
   * 添加
   * @param {String} key
   * @param {Array} value
   */
  set(key, value) {
    const loadFactor = (this.#count + 1) / this.#length;
    if (loadFactor > 0.75) {
      this.#resize(this.#length * 2);
    }
    const index = this.#hash(key);
    if (!this.#storage[index]) this.#storage[index] = [];
    this.#storage[index].push([key, value]);
    this.#count++;
  }

  /**
   * 删除
   * @param {String} key
   */
  delete(key) {
    const loadFactor = (this.#count - 1) / this.#length;
    if (loadFactor < 0.25 && this.#length > 7) {
      this.#resize(Math.ceil(this.#length / 2));
    }
    const index = this.#hash(key);
    const bucket = this.#storage[index];
    if (!bucket) return null;
    const elIndex = bucket.findIndex((item) => item[0] === key);
    if (elIndex === -1) return null;
    const value = bucket[elIndex][1];
    bucket.splice(elIndex, 1);
    this.#count--;
    return value;
  }

  print() {
    console.log(this.#storage);
    console.log(this.#length);
  }
}

// 测试代码
const hash = new HashTable();
hash.set('a', '111');
hash.set('b', '222');
hash.set('c', '333');
hash.set('h', '888');
hash.print();
hash.set('d', '444');
hash.set('e', '555');
hash.print();
console.log(hash.delete('a'));
console.log(hash.delete('b'));
hash.print();
console.log(hash.delete('c'));
console.log(hash.delete('d'));
console.log(hash.delete('e'));
hash.print();
```
